use std::{
    sync::{
        atomic::{AtomicU32, Ordering},
        Arc,
    },
    task::Poll,
    time::Duration,
};

use futures::FutureExt;
use moto_rt::time::Instant;
use moto_sys::SysHandle;

fn test_basic() {
    assert_eq!(42, moto_async::LocalRuntime::new().block_on(async { 42 }));
    println!("----- moto_async::test_basic PASS");
}

// A timeout future that returns the number of polls it got.
struct TimeoutFuture {
    polls: u64,
    inner: moto_async::time::Sleep,
}

impl TimeoutFuture {
    fn new(timo: std::time::Duration) -> Self {
        Self {
            polls: 0,
            inner: moto_async::time::Sleep::new_timeout(Instant::now() + timo),
        }
    }
}

impl core::future::Future for TimeoutFuture {
    type Output = u64;

    fn poll(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        self.polls += 1;
        match self.inner.poll_unpin(cx) {
            Poll::Ready(_) => Poll::Ready(self.polls),
            Poll::Pending => Poll::Pending,
        }
    }
}

fn test_timeout() {
    let start = Instant::now();
    let timo = std::time::Duration::from_millis(15);

    let fut = TimeoutFuture::new(timo);

    // Make sure that the future got at most two polls:
    // one the initial pending, and one the final ready.
    // If there are delays, the first poll may be ready.
    let poll_calls = moto_async::LocalRuntime::new().block_on(fut);
    assert!(start.elapsed() >= timo);

    if poll_calls == 1 {
        log::info!("test_timeout: a single poll() call");
    } else if poll_calls > 2 {
        panic!("Too many poll calls: {poll_calls}.");
    }

    println!("----- moto_async::test_timeout PASS");
}

fn test_select() {
    let counter = Arc::new(AtomicU32::new(0));

    let c1 = counter.clone();
    let c2 = counter.clone();

    let f1 = async move {
        moto_async::time::sleep(Duration::from_millis(50)).await;

        c1.fetch_add(1, Ordering::AcqRel);
    };

    let f2 = async move {
        moto_async::time::sleep(Duration::from_millis(150)).await;

        c2.fetch_add(2, Ordering::AcqRel);
    };

    let res = moto_async::LocalRuntime::new().block_on(async move {
        futures::select! {_ = f1.fuse() => 1, _ = f2.fuse() => 2}
    });

    assert_eq!(1, res);
    assert_eq!(1, counter.load(Ordering::Acquire));

    println!("----- moto_async::test_select PASS");
}

fn test_spawn() {
    moto_async::LocalRuntime::new().block_on(async {
        let join_1 = moto_async::LocalRuntime::spawn(async {
            moto_async::time::sleep(Duration::from_millis(20)).await;
            42
        });

        let join_2 = moto_async::LocalRuntime::spawn(async {
            moto_async::time::sleep(Duration::from_millis(40)).await;
            "foobar"
        });

        assert_eq!("foobar", join_2.await);
        assert_eq!(42, join_1.await);
    });
    println!("----- moto_async::test_spawn PASS");
}

fn test_interleaving() {
    use std::cell::RefCell;
    use std::rc::Rc;

    // Note: this test was generated by Gemini Pro 2.5 and modified by a human.
    let log = Rc::new(RefCell::new(Vec::new()));

    moto_async::LocalRuntime::new().block_on(async {
        // Spawn three tasks, each with a different sleep duration.
        let log1 = log.clone();
        let h1 = moto_async::LocalRuntime::spawn(async move {
            log1.borrow_mut().push(1);
            moto_async::time::sleep(Duration::from_millis(30)).await;
            log1.borrow_mut().push(6);
        });

        let log2 = log.clone();
        let h2 = moto_async::LocalRuntime::spawn(async move {
            log2.borrow_mut().push(2);
            moto_async::time::sleep(Duration::from_millis(20)).await;
            log2.borrow_mut().push(5);
        });

        let log3 = log.clone();
        let h3 = moto_async::LocalRuntime::spawn(async move {
            log3.borrow_mut().push(3);
            moto_async::time::sleep(Duration::from_millis(10)).await;
            log3.borrow_mut().push(4);
        });

        h1.await;
        h2.await;
        h3.await;

        assert_eq!(
            *log.borrow(),
            vec![1, 2, 3, 4, 5, 6],
            "Tasks didn't interleave as expected."
        );
    });

    println!("----- moto_async::test_interleaving PASS");
}

fn test_nested_tasks() {
    // Note: this test was generated by Gemini Pro 2.5 and modified by a human.
    moto_async::LocalRuntime::new().block_on(async {
        let handle_a = moto_async::LocalRuntime::spawn(async {
            let handle_b = moto_async::LocalRuntime::spawn(async {
                moto_async::time::sleep(Duration::from_millis(10)).await;
                1337
            });
            let value_from_b = handle_b.await;
            format!("Task A processed value: {}", value_from_b)
        });

        let final_result = handle_a.await;
        assert_eq!(
            final_result, "Task A processed value: 1337",
            "Value should be correctly propagated from child to parent"
        );
    });
    println!("----- moto_async::test_nested_tasks PASS");
}

fn test_event_listener() {
    // Test a ping-pong across threads.
    const ITERS: u32 = 100;
    let (handle_here, handle_there) =
        moto_sys::SysObj::create_ipc_pair(SysHandle::SELF, SysHandle::SELF, 0).unwrap();

    let channel_here = Arc::new(AtomicU32::new(0));
    let channel_there = channel_here.clone();

    let runtime_thread = std::thread::spawn(move || {
        moto_async::LocalRuntime::new().block_on(async move {
            let _ = moto_async::LocalRuntime::spawn_event_listener(
                handle_there,
                async move |event_stream| {
                    for step in 0..ITERS {
                        assert_eq!(step * 2, channel_there.fetch_add(1, Ordering::AcqRel));
                        moto_sys::SysCpu::wake(handle_there).unwrap();
                        event_stream.next().await;
                    }
                },
            )
            .await;
        });
    });

    for step in 0..ITERS {
        let mut handles = [handle_here];
        moto_sys::SysCpu::wait(&mut handles, SysHandle::NONE, SysHandle::NONE, None).unwrap();
        assert_eq!(step * 2 + 1, channel_here.fetch_add(1, Ordering::AcqRel));
        moto_sys::SysCpu::wake(handle_here).unwrap();
    }

    runtime_thread.join().unwrap();
    println!("----- moto_async::test_event_listener PASS");
}

pub fn run_all_tests() {
    test_basic();
    test_timeout();
    test_select();
    test_spawn();
    test_interleaving();
    test_nested_tasks();
    test_event_listener();

    // test_cancelled_task();
    // test_double_wake();
    // test_sent_waker();

    println!("moto_async all PASS");
}
