use std::{
    sync::{
        Arc,
        atomic::{AtomicU32, Ordering},
    },
    task::Poll,
    time::Duration,
};

use futures::FutureExt;
use moto_async::AsFuture;
use moto_rt::time::Instant;
use moto_sys::SysHandle;

fn test_basic() {
    assert_eq!(42, moto_async::LocalRuntime::new().block_on(async { 42 }));
    println!("----- moto_async::test_basic PASS");
}

// A timeout future that returns the number of polls it got.
struct TimeoutFuture {
    polls: u64,
    inner: moto_async::Sleep,
}

impl TimeoutFuture {
    fn new(timo: std::time::Duration) -> Self {
        Self {
            polls: 0,
            inner: moto_async::Sleep::new_timeout(Instant::now() + timo),
        }
    }
}

impl core::future::Future for TimeoutFuture {
    type Output = u64;

    fn poll(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Self::Output> {
        self.polls += 1;
        match self.inner.poll_unpin(cx) {
            Poll::Ready(_) => Poll::Ready(self.polls),
            Poll::Pending => Poll::Pending,
        }
    }
}

fn test_timeout() {
    let start = Instant::now();
    let timo = std::time::Duration::from_millis(15);

    let fut = TimeoutFuture::new(timo);

    // Make sure that the future got at most two polls:
    // one the initial pending, and one the final ready.
    // If there are delays, the first poll may be ready.
    let poll_calls = moto_async::LocalRuntime::new().block_on(fut);
    assert!(start.elapsed() >= timo);

    if poll_calls == 1 {
        log::info!("test_timeout: a single poll() call");
    } else if poll_calls > 2 {
        panic!("Too many poll calls: {poll_calls}.");
    }

    println!("----- moto_async::test_timeout PASS");
}

fn test_select() {
    let counter = Arc::new(AtomicU32::new(0));

    let c1 = counter.clone();
    let c2 = counter.clone();

    let f1 = async move {
        moto_async::sleep(Duration::from_millis(50)).await;

        c1.fetch_add(1, Ordering::AcqRel);
    };

    let f2 = async move {
        moto_async::sleep(Duration::from_millis(150)).await;

        c2.fetch_add(2, Ordering::AcqRel);
    };

    let res = moto_async::LocalRuntime::new().block_on(async move {
        futures::select! {_ = f1.fuse() => 1, _ = f2.fuse() => 2}
    });

    assert_eq!(1, res);
    assert_eq!(1, counter.load(Ordering::Acquire));

    println!("----- moto_async::test_select PASS");
}

fn test_spawn() {
    moto_async::LocalRuntime::new().block_on(async {
        let join_1 = moto_async::LocalRuntime::spawn(async {
            moto_async::sleep(Duration::from_millis(20)).await;
            42
        });

        let join_2 = moto_async::LocalRuntime::spawn(async {
            moto_async::sleep(Duration::from_millis(40)).await;
            "foobar"
        });

        assert_eq!("foobar", join_2.await);
        assert_eq!(42, join_1.await);
    });
    println!("----- moto_async::test_spawn PASS");
}

fn test_interleaving() {
    use std::cell::RefCell;
    use std::rc::Rc;

    // Note: this test was generated by Gemini Pro 2.5 and modified by a human.
    let log = Rc::new(RefCell::new(Vec::new()));

    moto_async::LocalRuntime::new().block_on(async {
        // Spawn three tasks, each with a different sleep duration.
        let log1 = log.clone();
        let h1 = moto_async::LocalRuntime::spawn(async move {
            log1.borrow_mut().push(1);
            moto_async::sleep(Duration::from_millis(30)).await;
            log1.borrow_mut().push(6);
        });

        let log2 = log.clone();
        let h2 = moto_async::LocalRuntime::spawn(async move {
            log2.borrow_mut().push(2);
            moto_async::sleep(Duration::from_millis(20)).await;
            log2.borrow_mut().push(5);
        });

        let log3 = log.clone();
        let h3 = moto_async::LocalRuntime::spawn(async move {
            log3.borrow_mut().push(3);
            moto_async::sleep(Duration::from_millis(10)).await;
            log3.borrow_mut().push(4);
        });

        h1.await;
        h2.await;
        h3.await;

        assert_eq!(
            *log.borrow(),
            vec![1, 2, 3, 4, 5, 6],
            "Tasks didn't interleave as expected."
        );
    });

    println!("----- moto_async::test_interleaving PASS");
}

fn test_nested_tasks() {
    // Note: this test was generated by Gemini Pro 2.5 and modified by a human.
    moto_async::LocalRuntime::new().block_on(async {
        let handle_a = moto_async::LocalRuntime::spawn(async {
            let handle_b = moto_async::LocalRuntime::spawn(async {
                moto_async::sleep(Duration::from_millis(10)).await;
                1337
            });
            let value_from_b = handle_b.await;
            format!("Task A processed value: {}", value_from_b)
        });

        let final_result = handle_a.await;
        assert_eq!(
            final_result, "Task A processed value: 1337",
            "Value should be correctly propagated from child to parent"
        );
    });
    println!("----- moto_async::test_nested_tasks PASS");
}

fn test_event_stream() {
    // Test ping-pong across threads.
    const ITERS: u32 = 100;
    let (handle_here, handle_there) =
        moto_sys::SysObj::create_ipc_pair(SysHandle::SELF, SysHandle::SELF, 0).unwrap();

    let channel_here = Arc::new(AtomicU32::new(0));
    let channel_there = channel_here.clone();

    let runtime_thread = std::thread::spawn(move || {
        moto_async::LocalRuntime::new().block_on(async move {
            for step in 0..ITERS {
                assert_eq!(step * 2, channel_there.fetch_add(1, Ordering::AcqRel));
                moto_sys::SysCpu::wake(handle_there).unwrap();
                handle_there.as_future().await.unwrap();
            }
        })
    });

    for step in 0..ITERS {
        let mut handles = [handle_here];
        moto_sys::SysCpu::wait(&mut handles, SysHandle::NONE, SysHandle::NONE, None).unwrap();
        assert_eq!(step * 2 + 1, channel_here.fetch_add(1, Ordering::AcqRel));
        moto_sys::SysCpu::wake(handle_here).unwrap();
    }

    runtime_thread.join().unwrap();
    println!("----- moto_async::test_event_stream PASS");
}

fn test_wake_exit_race() {
    let (handle_here, handle_there) =
        moto_sys::SysObj::create_ipc_pair(SysHandle::SELF, SysHandle::SELF, 0).unwrap();

    let runtime_thread = std::thread::spawn(move || {
        moto_async::LocalRuntime::new().block_on(async move {
            for _ in 0..5 {
                futures::select! {
                    _ = handle_there.as_future().fuse() => (),
                    _ = moto_async::sleep(Duration::from_millis(20)).fuse() => (),
                };
            }
        });
    });

    for _ in 0..5 {
        std::thread::sleep(Duration::from_millis(20));
        moto_sys::SysCpu::wake(handle_here).unwrap();
    }

    runtime_thread.join().unwrap();

    println!("----- moto_async::test_wake_exit_race PASS");
}

fn test_mutex() {
    // The test is based on a test was generated by Gemini 2.5 Pro.
    const NUM_TASKS: usize = 100;
    let start = std::time::Instant::now();
    moto_async::LocalRuntime::new().block_on(async {
        let counter = std::rc::Rc::new(moto_async::LocalMutex::new(0_usize));

        let mut tasks = Vec::with_capacity(NUM_TASKS);

        for _ in 0..NUM_TASKS {
            let counter_clone = counter.clone();

            let task = moto_async::LocalRuntime::spawn(async move {
                let mut num = counter_clone.lock().await;
                *num += 1;
            });
            tasks.push(task);
        }

        for task in tasks {
            task.await;
        }

        let final_count = *counter.lock().await;
        assert_eq!(
            final_count, NUM_TASKS,
            "The final count should equal the number of tasks spawned."
        );
    });
    println!(
        "----- moto_async::test_mutex PASS ({NUM_TASKS} tasks in {:?})",
        start.elapsed()
    );
}

fn test_mutex_cancel_safety() {
    // The test is based on a test was generated by Gemini 2.5 Pro.
    moto_async::LocalRuntime::new().block_on(async {
        let mutex = std::rc::Rc::new(moto_async::LocalMutex::new(0_usize));
        let initial_lock = mutex.lock().await;

        let mutex_clone = mutex.clone();
        let cancel_task = moto_async::LocalRuntime::spawn(async move {
            let f1 = mutex_clone.lock();
            let f2 = moto_async::sleep(Duration::from_millis(20));
            let res = futures::select! {_ = f1.fuse() => 1, _ = f2.fuse() => 2};
            assert_eq!(res, 2);
        });

        // Sleep a bit so that f1 above gets polled.
        moto_async::sleep(Duration::from_millis(10)).await;

        // Spawn a second mutex waiter.
        let mutex_clone = mutex.clone();
        let later_task = moto_async::LocalRuntime::spawn(async move {
            *mutex_clone.lock().await += 1;
        });

        cancel_task.await;

        // The initial lock still holds.
        assert_eq!(0, *initial_lock);

        drop(initial_lock);
        later_task.await;

        // The later task has incremented the mutex.
        assert_eq!(*mutex.lock().await, 1);
    });
    println!("----- moto_async::test_mutex_cancel_safety PASS");
}

pub fn test_oneshot() {
    let (sender_ping, receiver_ping) = moto_async::oneshot();
    let (sender_pong, receiver_pong) = moto_async::oneshot();

    let runtime_thread = std::thread::spawn(move || {
        moto_async::LocalRuntime::new().block_on(async move {
            let val = receiver_ping.await.unwrap();
            assert_eq!(val, 42);
            sender_pong.send(43_u32).unwrap();
        });
    });

    std::thread::sleep(Duration::from_millis(10));
    sender_ping.send(42_u32).unwrap();

    moto_async::LocalRuntime::new().block_on(async move {
        let val = receiver_pong.await.unwrap();
        assert_eq!(val, 43);
    });

    let _ = runtime_thread.join();

    println!("----- moto_async::test_oneshot PASS");
}

pub fn run_all_tests() {
    test_basic();
    test_timeout();
    test_select();
    test_spawn();
    test_interleaving();
    test_nested_tasks();
    test_event_stream();
    test_wake_exit_race();
    test_mutex();
    test_mutex_cancel_safety();
    test_oneshot();

    println!("moto_async all PASS");
}
