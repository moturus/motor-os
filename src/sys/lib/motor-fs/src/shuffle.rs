//! Shuffle u64 around, somewhat randomly.
//!
//! The code was generated by Gemini 2.5 Pro.

const ROUNDS: usize = 8;

/// FNV-1a hash.
///
/// See https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function
#[allow(unused)]
pub fn fnv1a_hash_64(bytes: &[u8]) -> u64 {
    let mut hash: u64 = 0xcbf29ce484222325; // FNV_OFFSET_BASIS
    const FNV_PRIME: u64 = 0x100000001b3; // FNV_PRIME

    for byte in bytes {
        hash ^= *byte as u64;
        hash = hash.wrapping_mul(FNV_PRIME);
    }

    hash
}
/// A simple, fast, non-cryptographic hash function (FNV-1a).
/// We use this to derive round keys from the seed.
fn fnv1a_hash_32(data: &[u8]) -> u32 {
    let mut hash: u32 = 0x811c9dc5; // FNV offset basis
    for byte in data {
        hash ^= *byte as u32;
        hash = hash.wrapping_mul(0x01000193); // FNV prime
    }
    hash
}

/// Generates a unique set of round keys from a given seed.
fn generate_round_keys(seed: u64) -> [u32; ROUNDS] {
    let mut keys = [0u32; ROUNDS];
    let seed_bytes = seed.to_be_bytes();
    #[allow(clippy::needless_range_loop)]
    for i in 0..ROUNDS {
        // Combine seed and round number to get a unique key per round
        let mut data_to_hash = Vec::from(seed_bytes);
        data_to_hash.push(i as u8);
        keys[i] = fnv1a_hash_32(&data_to_hash);
    }
    keys
}

// A simple, non-cryptographic round function.
// A better implementation might use a more complex hash.
fn round_function(val: u32, round_key: u32) -> u32 {
    val.wrapping_add(round_key).wrapping_mul(0xdeadbeef)
}

/// Shuffles a u64 using a Feistel network with a given seed.
pub fn shuffle_u64(n: u64, seed: u64) -> u64 {
    let round_keys = generate_round_keys(seed);
    let mut left = (n >> 32) as u32;
    let mut right = n as u32;

    #[allow(clippy::needless_range_loop)]
    for i in 0..ROUNDS {
        let temp = left ^ round_function(right, round_keys[i]);
        left = right;
        right = temp;
    }

    ((left as u64) << 32) | (right as u64)
}

/// The exact inverse of shuffle_u64, requiring the same seed.
#[cfg(test)]
pub fn unshuffle_u64(n: u64, seed: u64) -> u64 {
    let round_keys = generate_round_keys(seed);
    let mut left = (n >> 32) as u32;
    let mut right = n as u32;

    for i in (0..ROUNDS).rev() {
        let temp = right ^ round_function(left, round_keys[i]);
        right = left;
        left = temp;
    }

    ((left as u64) << 32) | (right as u64)
}

#[test]
fn shuffle() {
    for _ in 0..1_000 {
        let original: u64 = std::random::random(..);
        let seed: u64 = std::random::random(..);
        let shuffled = shuffle_u64(original, seed);
        let unshuffled = unshuffle_u64(shuffled, seed);

        assert_eq!(original, unshuffled);
    }
}
